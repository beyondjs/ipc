/************
Processor: ts
************/

// child/actions.ts
declare namespace ns_0 {
  import ActionHandlerType = ns_6.ActionHandlerType;
  export class _default {
    #private;
    handle(action: string, listener: ActionHandlerType): void;
    removeHandler(action: string): boolean;
    constructor();
    destroy(): void;
  }
}


// child/events.ts
declare namespace ns_1 {
  import EventListenerType = ns_6.EventListenerType;
  export class _default {
    #private;
    constructor();
    emit(event: string, data: any): void;
    on(processTag: string, event: string, listener: EventListenerType): void;
    off(processTag: string, event: string, listener: EventListenerType): void;
    destroy(): void;
  }
}


// child/index.ts
declare namespace ns_2 {
  import Actions = ns_0._default;
  import Events = ns_1._default;
  export class _default extends Actions {
    #private;
    get instance(): string;
    get events(): Events;
    constructor();
    notify(event: string, message: any): void;
    /**
     * Execute an IPC action
     *
     * @param target The name of the target process
     * @param action The nam	e of the action being requested
     * @param params The parameters of the action
     * @returns {*}
     */
    exec(target: string | undefined, action: string, ...params: any[]): Promise<any>;
    destroy(): void;
  }
}


// dispatcher/index.ts
declare namespace ns_3 {
  /// <reference types="node" />
  export class _default {
    #private;
    constructor(container: {
      instance: string;
    }, fork: NodeJS.Process);
    /**
     * Execute an IPC action
     */
    exec(target: string | undefined, action: string, ...params: any[]): Promise<any>;
    destroy(): void;
  }
}


// error.ts
declare namespace ns_4 {
  export class _default extends Error {
    constructor(error: Error | string);
  }
  export class VersionError extends Error {
    constructor(requested: string);
  }
}


// index.ts
declare namespace ns_5 {
  export {};
}


// interfaces/index.ts
declare namespace ns_6 {
  export type ActionHandlerType = (...params: any[]) => any;
  export type EventListenerType = (data: any) => void;
  export const version = "1.0.0";
  /**
   * Action call request
   */
  export interface IActionRequest {
    version: typeof version;
    type: 'ipc.action.request';
    ipc: {
      instance: string;
    };
    id: number;
    target: string;
    action: string;
    params: any[];
  }
  /**
   * Action response
   */
  export interface IActionResponse {
    version: typeof version;
    type: 'ipc.action.response';
    ipc: {
      instance: string;
    };
    request: {
      id: number;
    };
    response?: any;
    error?: Error | string;
  }
  /**
   * Child event emit
   */
  export interface IEvent {
    version: typeof version;
    type: 'ipc.event';
    event: string;
    data: any;
  }
  /**
   * Used for child to child communication, to inform the main process about the event subscription.
   * The main process uses the concept of bridges to route the other child events
   */
  export interface IC2CSubscribe {
    version: typeof version;
    type: 'ipc.c2c.event.subscribe';
    processTag: string;
    event: string;
  }
  export interface IC2CUnsubscribe {
    version: typeof version;
    type: 'ipc.c2c.event.unsubscribe';
    processTag: string;
    event: string;
  }
  /**
   * Used for events in a child to child communication to route the event to their subscribers
   */
  export interface IC2CEventRoute {
    version: typeof version;
    type: 'ipc.c2c.event.route';
    processTag: string;
    event: string;
    data: any;
  }
}


// main/actions/index.ts
declare namespace ns_7 {
  /// <reference types="node" />
  import Dispatcher = ns_3._default;
  import ActionHandlerType = ns_6.ActionHandlerType;
  export class _default {
    #private;
    constructor(dispatchers: Map<string, Dispatcher>);
    handle: (action: string, handler: ActionHandlerType) => Map<string, ActionHandlerType>;
    off: (action: string) => boolean;
    has: (action: string) => boolean;
    /**
     * Register a forked process to hear for actions requests
     *
     * @param name {string} The name assigned to the forked process
     * @param fork {object} The forked process
     */
    registerFork(name: string, fork: NodeJS.Process): void;
    exec(action: string, ...params: any[]): Promise<any>;
    destroy(): void;
  }
}


// main/actions/routers/child.ts
declare namespace ns_8 {
  /// <reference types="node" />
  import Dispatcher = ns_3._default;
  import Server = ns_7._default;
  export class _default {
    #private;
    constructor(actions: Server, fork: NodeJS.Process, dispatchers: Map<string, Dispatcher>);
    destroy(): void;
  }
}


// main/actions/routers/index.ts
declare namespace ns_9 {
  /// <reference types="node" />
  import Dispatcher = ns_3._default;
  import Actions = ns_7._default;
  export class _default {
    #private;
    constructor(actions: Actions, dispatchers: Map<string, Dispatcher>);
    register(name: string, fork: NodeJS.Process): void;
    destroy(): void;
  }
}


// main/events/index.ts
declare namespace ns_10 {
  import EventListenerType = ns_6.EventListenerType;
  export class _default {
    #private;
    constructor();
    /**
     * Register a listener for an event received from a given child process
     *
     * @param child The child process name given when it was registered in the IPC
     * @param event The event name
     * @param listener The callback to be executed when the event occurs
     */
    on(child: string, event: string, listener: EventListenerType): void;
    /**
     * Remove a registered event listener
     *
     * @param child The child process name given when it was registered in the IPC
     * @param event The event name
     * @param listener The previously registered listener function
     */
    off(child: string, event: string, listener: EventListenerType): void;
    emit(event: string, data: any): void;
    /**
     * Register a fork process to hear for actions requests
     */
    registerFork: (name: string, fork: NodeJS.Process) => void;
  }
}


// main/events/routers/child.ts
declare namespace ns_11 {
  /// <reference types="node" />
  import Bridges = ns_12._default;
  export class _default {
    #private;
    constructor(routes: Bridges, tag: string, fork: NodeJS.Process);
    /**
     * Route the event if the forked process is registered to it.
     * The execution of this method is expected to be made only by the index.ts file (the routes collection).
     *
     * @param processTag The tag of the process that is sending the event
     * @param event The event name
     * @param data The data to be sent
     */
    route(processTag: string, event: string, data: any): void;
    destroy(): void;
  }
}


// main/events/routers/index.ts
declare namespace ns_12 {
  /// <reference types="node" />
  export class _default {
    #private;
    route(sourceProcessTag: string, event: string, data: any): void;
    register(tag: string, fork: NodeJS.Process): void;
    destroy(): void;
  }
}


// main/index.ts
declare namespace ns_13 {
  /// <reference types="node" />
  import Events = ns_10._default;
  type ListenerType = (...[]: Iterable<any>) => any;
  export class _default {
    #private;
    get instance(): string;
    handle(action: string, listener: ListenerType): void;
    removeHandler(action: string): void;
    get events(): Events;
    notify(event: string, message: any): void;
    register(name: string, fork: NodeJS.Process): void;
    unregister(name: string): void;
    /**
     * Execute an IPC action
     */
    exec(target: string | undefined, action: string, ...params: any[]): Promise<any>;
    destroy(): void;
  }
  export {};
}



export declare const hmr: {on: (event: string, listener: any) => void, off: (event: string, listener: any) => void };